#!/usr/bin/env node

/**
 * Collect Component Metadata
 *
 * Scans all component directories and collects metadata.ts files
 * Generates a single metadata export for the MCP server
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const COMPONENTS_DIR = path.resolve(__dirname, '../src/components');
const OUTPUT_FILE = path.resolve(__dirname, '../src/metadata-index.ts');

console.log('Collecting component metadata...\n');

// Get all component directories
const componentDirs = fs
  .readdirSync(COMPONENTS_DIR, { withFileTypes: true })
  .filter((dirent) => dirent.isDirectory())
  .map((dirent) => dirent.name)
  .sort();

console.log(`Found ${componentDirs.length} component directories`);

// Check which have metadata.ts
const componentsWithMetadata = [];
const componentsMissingMetadata = [];

for (const dir of componentDirs) {
  const metadataPath = path.join(COMPONENTS_DIR, dir, 'metadata.ts');
  if (fs.existsSync(metadataPath)) {
    componentsWithMetadata.push(dir);
  } else {
    componentsMissingMetadata.push(dir);
  }
}

console.log(`\n✓ ${componentsWithMetadata.length} with metadata:`);
componentsWithMetadata.forEach((name) => console.log(`  - ${name}`));

if (componentsMissingMetadata.length > 0) {
  console.log(`\n⚠ ${componentsMissingMetadata.length} missing metadata:`);
  componentsMissingMetadata.forEach((name) => console.log(`  - ${name}`));
}

// Generate metadata index file
const imports = componentsWithMetadata
  .map((dir) => `import { metadata as ${toCamelCase(dir)}Metadata } from './components/${dir}/metadata.js';`)
  .join('\n');

const exports = componentsWithMetadata
  .map((dir) => `  ${toCamelCase(dir)}Metadata,`)
  .join('\n');

const content = `/**
 * Component Metadata Index
 * Auto-generated by scripts/collect-metadata.mjs
 * DO NOT EDIT MANUALLY
 */

import type { ComponentMetadata } from './types/metadata.js';

${imports}

export const ALL_COMPONENT_METADATA: ComponentMetadata[] = [
${exports}
];

export function findComponentMetadata(query: string): ComponentMetadata | undefined {
  const lowerQuery = query.toLowerCase();
  return ALL_COMPONENT_METADATA.find(
    (c) =>
      c.name.toLowerCase() === lowerQuery ||
      c.tagName.toLowerCase() === lowerQuery ||
      c.description.toLowerCase().includes(lowerQuery)
  );
}

export function searchComponentMetadata(query: string): ComponentMetadata[] {
  const lowerQuery = query.toLowerCase();
  return ALL_COMPONENT_METADATA.filter(
    (c) =>
      c.name.toLowerCase().includes(lowerQuery) ||
      c.tagName.toLowerCase().includes(lowerQuery) ||
      c.description.toLowerCase().includes(lowerQuery) ||
      c.category.toLowerCase().includes(lowerQuery)
  );
}

export function getComponentMetadataByCategory(category: string): ComponentMetadata[] {
  return ALL_COMPONENT_METADATA.filter((c) => c.category === category);
}
`;

fs.writeFileSync(OUTPUT_FILE, content, 'utf-8');

console.log(`\n✓ Generated ${OUTPUT_FILE}`);
console.log(`\nMetadata collection complete!`);

if (componentsMissingMetadata.length > 0) {
  console.log(`\nℹ To add metadata for remaining components, create metadata.ts files in:`);
  componentsMissingMetadata.slice(0, 5).forEach((name) => {
    console.log(`  packages/core/src/components/${name}/metadata.ts`);
  });
  if (componentsMissingMetadata.length > 5) {
    console.log(`  ... and ${componentsMissingMetadata.length - 5} more`);
  }
}

/**
 * Convert kebab-case to camelCase
 */
function toCamelCase(str) {
  return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}
