# 質問への回答と推奨事項

## いただいた質問への回答

### 1. ドキュメントツールについて

#### Storybook vs VitePress - それぞれの特徴

**Storybook**

- **目的**: コンポーネントカタログ・開発環境
- **特徴**:
  - コンポーネントを独立した環境で開発・テスト
  - インタラクティブなコントロール（props を UI で変更）
  - アドオンが豊富（アクセシビリティチェック、ビジュアルテスト等）
  - Web Components、React、Vue すべてサポート
  - ホットリロードで即座にプレビュー
- **適している用途**: コンポーネントのデモとインタラクティブな実験

**VitePress**

- **目的**: ドキュメントサイト構築
- **特徴**:
  - Markdown ベースの静的サイトジェネレーター
  - ガイド、チュートリアル、API リファレンスに最適
  - 高速（Vite ベース）
  - SEO に強い
  - カスタム Vue コンポーネントを埋め込み可能
- **適している用途**: 包括的なドキュメント（導入ガイド、デザイン原則、使い方等）

#### 組み合わせ方（推奨）

```
packages/
  ├── docs/           # VitePress でドキュメントサイト
  │   ├── guide/      # 導入ガイド、コンセプト
  │   ├── components/ # 各コンポーネントの説明
  │   └── api/        # API リファレンス
  └── storybook/      # Storybook でコンポーネントカタログ
      └── stories/    # 各コンポーネントのストーリー
```

**連携方法**:

- VitePress のドキュメントから Storybook へリンク
- Storybook の iframe を VitePress に埋め込み
- VitePress = 「何を作るか、どう使うか」
- Storybook = 「実際に触って試す」

**推奨**: 両方使用することで、最高の開発者体験を提供できます。

---

### 2. コードサンプルの表示方法

#### 選択肢

1. **シンタックスハイライト付きコードブロック**

   ```html
   <ds-button variant="primary">Click me</ds-button>
   ```

2. **ライブコードエディター**
   - ユーザーがその場でコードを編集して結果を確認
   - ツール: CodeSandbox、StackBlitz の埋め込み、または独自実装

3. **コピー可能なスニペット**
   - ワンクリックでコードをコピーできるボタン付き

4. **タブ切り替え**
   - Vanilla JS、React、Vue のコードを切り替えて表示
   ```html
   <!-- Vanilla JS -->
   <ds-button>Click me</ds-button>
   ```
   ```jsx
   // React
   <Button>Click me</Button>
   ```
   ```vue
   <!-- Vue -->
   <ds-button>Click me</ds-button>
   ```

**推奨**: Storybook では (2) のライブエディター、VitePress では (1)(3)(4) の組み合わせ

---

### 3. JSDoc から API ドキュメント自動生成

#### 可能です！

**ツール**: Custom Elements Manifest（CEM）

```typescript
/**
 * ボタンコンポーネント
 * @slot - ボタンのコンテンツ
 * @fires click - ボタンがクリックされた時
 */
export class DsButton extends HTMLElement {
  /**
   * ボタンのバリアント
   * @type {'primary' | 'secondary' | 'outline'}
   * @attr
   */
  variant = "primary";
}
```

**自動生成される情報**:

- プロパティ/属性の一覧と型
- イベントの一覧
- スロットの説明
- 使用例

**出力先**:

- VitePress の API リファレンスページ
- Storybook の Docs タブ
- JSON ファイル（他ツールでも利用可能）

**推奨**: 実装します。JSDoc を書くだけで自動的にドキュメント生成されます。

---

### 4. パッケージ構成について

#### 追加で検討すべきパッケージ

```
packages/
  ├── core/           # Web Components本体
  ├── react/          # Reactラッパー
  ├── vue/            # Vueラッパー
  ├── tokens/         # デザイントークン
  ├── docs/           # VitePress ドキュメント
  ├── storybook/      # Storybook（NEW）
  ├── utils/          # 共通ユーティリティ（NEW・オプション）
  └── examples/       # サンプルアプリ（NEW・オプション）
```

**utils パッケージ**（オプション）:

- 複数パッケージで共有するヘルパー関数
- 例: カラー変換、アクセシビリティユーティリティ等

**examples パッケージ**（オプション）:

- 実際のアプリケーション例
- React アプリ、Vue アプリのサンプル
- ユーザーがすぐに動かせるテンプレート

**推奨**: 最初は基本構成で開始し、必要に応じて追加

---

### 5. スコープパッケージとは

#### 説明

NPM のパッケージ名には2種類あります：

**通常のパッケージ**:

```bash
npm install design-system
```

- グローバルな名前空間で一意である必要がある
- 既に誰かが使っている名前は使えない
- 例: `lodash`, `react`, `vue`

**スコープパッケージ**:

```bash
npm install @your-org/design-system
npm install @your-org/tokens
npm install @your-org/react
```

- `@` で始まり、組織名やユーザー名をスコープとする
- スコープ内でのみ一意であれば良い
- 関連パッケージをグループ化できる

#### メリット

1. **名前の衝突を防ぐ**: 他の人と同じパッケージ名でも問題ない
2. **関連性が明確**: すべてのパッケージが `@your-org/` で始まる
3. **プライベートパッケージ**: NPM の有料プランで非公開にできる

#### 例

```json
// package.json の例
{
  "name": "@acme/design-system-core",
  "dependencies": {
    "@acme/tokens": "^1.0.0"
  }
}
```

**推奨**: スコープパッケージを使用（モダンな慣習）

#### パッケージ名の提案

- `@your-org/core`
- `@your-org/react`
- `@your-org/vue`
- `@your-org/tokens`

組織名（your-org の部分）は GitHub ユーザー名や組織名に合わせるのが一般的です。

---

### 6. フォーカス管理の戦略

#### 主な手法

**1. タブ順序の制御**

- `tabindex` 属性の適切な使用
- 論理的な順序でフォーカス移動

**2. フォーカストラップ**

- モーダルやダイアログ内でフォーカスを閉じ込める
- `Tab` で最後の要素から最初に戻る

**3. フォーカスの復元**

- モーダルを閉じたら、開く前の要素にフォーカスを戻す

**4. フォーカスインジケーター**

- `:focus-visible` でキーボード使用時のみアウトライン表示
- マウスクリック時は表示しない

**5. 無効状態の管理**

- 無効なコンポーネントは `tabindex="-1"` または `disabled`

#### 実装例

```typescript
// モーダルのフォーカストラップ
class DsModal extends HTMLElement {
  private previousFocus?: HTMLElement;

  open() {
    // 現在のフォーカスを保存
    this.previousFocus = document.activeElement as HTMLElement;

    // モーダル内の最初のフォーカス可能要素にフォーカス
    const firstFocusable = this.querySelector(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
    );
    firstFocusable?.focus();
  }

  close() {
    // フォーカスを復元
    this.previousFocus?.focus();
  }
}
```

**推奨**: 標準的なフォーカス管理パターンを実装し、ライブラリ（focus-trap など）も活用

---

### 7. スタイリング方法の推奨

Web Components のスタイリングには以下を推奨します：

#### CSS Custom Properties（CSS変数）+ Constructable Stylesheets

**理由**:

1. **CSS Custom Properties**
   - テーマの切り替えが簡単
   - 外部からのカスタマイズが可能
   - ダークモード対応が容易

   ```css
   :host {
     background: var(--ds-color-primary);
     padding: var(--ds-spacing-md);
   }
   ```

2. **Constructable Stylesheets**
   - パフォーマンスが良い（スタイルを複数のコンポーネントで共有）
   - 動的にスタイルを変更可能

   ```typescript
   const sheet = new CSSStyleSheet();
   sheet.replaceSync(`:host { color: red; }`);
   this.shadowRoot.adoptedStyleSheets = [sheet];
   ```

3. **CSS Parts**
   - 外部から特定の部分をスタイリング可能
   ```html
   <ds-button>
     <button part="button">Click</button>
   </ds-button>
   ```
   ```css
   /* 外部から */
   ds-button::part(button) {
     font-weight: bold;
   }
   ```

**構成**:

```
styles/
  ├── tokens.css        # デザイントークン（CSS変数）
  ├── base.css          # 共通スタイル
  └── components/       # コンポーネント別スタイル
```

**推奨**: CSS Custom Properties + Constructable Stylesheets + CSS Parts

---

## 決定事項まとめ

### 確定項目

✅ **コンポーネント優先順位**

1. Button, Input, Checkbox（ベーシック）
2. Container, Grid, Stack（レイアウト）
3. FormGroup, Select, Textarea（フォーム）
4. Tabs, Menu, Breadcrumb（ナビゲーション）
5. Alert, Toast, Modal（フィードバック）
6. Table, Card, Badge（データ表示）

✅ **フレームワーク**

- Vanilla JS（Web Component）
- React
- Vue 3

✅ **デザイントークン**

- すべてのトークンタイプを実装（カラー、タイポグラフィ、スペーシング、ボーダー、シャドウ、アニメーション、ブレークポイント）
- Style Dictionary + YAML
- ダークモード対応
- 複数テーマ対応
- カスタムテーマ対応

✅ **技術スタック**

- ビルド: Vite + Turborepo
- 言語: TypeScript（型定義提供）
- スタイリング: CSS Custom Properties + Constructable Stylesheets + CSS Parts
- テスト: すべて実装（Vitest, Playwright, Chromatic/Percy）

✅ **ドキュメント**

- Storybook（コンポーネントカタログ）
- VitePress（ドキュメントサイト）
- JSDoc から API ドキュメント自動生成（Custom Elements Manifest）
- インタラクティブプレビュー
- Vanilla JS / React / Vue のコードサンプル切り替え

✅ **配布**

- NPM 公開
- スコープパッケージ使用（推奨）
- CDN 対応（unpkg, jsdelivr）

✅ **アクセシビリティ**

- WCAG 2.1 Level A
- ARIA 属性をしっかり実装
- すべてのコンポーネントでキーボード操作
- 標準的なフォーカス管理パターン

✅ **ブラウザサポート**

- モダンブラウザ最新版
- モバイルブラウザ対応
- IE11 サポート不要

✅ **開発フロー**

- Git リポジトリ作成予定
- Git Flow
- CI/CD（自動テスト・ビルド・デプロイ）
- セマンティックバージョニング
- Changelog 自動生成

✅ **その他**

- 参考デザインシステムなし（独自設計）
- Figma 連携不要
- スタイルのカスタマイズを許容（CSS Parts/Custom Properties）

---

## 推奨パッケージ構成（最終版）

```
packages/
  ├── core/           # Web Components 本体（TypeScript）
  ├── react/          # React ラッパー
  ├── vue/            # Vue 3 ラッパー
  ├── tokens/         # デザイントークン（YAML → Style Dictionary）
  ├── docs/           # VitePress ドキュメントサイト
  └── storybook/      # Storybook コンポーネントカタログ
```

---

## 次のステップ

### フェーズ 1: プロジェクト基盤構築

1. モノレポのセットアップ（Turborepo）
2. 各パッケージの package.json 作成
3. TypeScript 設定
4. Vite 設定

### フェーズ 2: デザイントークン

1. トークン定義（YAML）
2. Style Dictionary 設定
3. CSS Variables 出力
4. テーマシステム構築

### フェーズ 3: 最初のコンポーネント（Button）

1. Web Component 実装
2. React ラッパー作成
3. Vue ラッパー作成
4. Storybook ストーリー作成
5. テスト作成
6. ドキュメント作成

### フェーズ 4: 開発環境整備

1. テスト環境セットアップ
2. CI/CD パイプライン構築
3. ドキュメントサイト構築
4. リリースフロー確立

---

## 残りの決定事項

### パッケージ名（要決定）

スコープパッケージを使用する場合、組織名が必要です：

**オプション**:

1. `@your-company/design-system` （会社名）
2. `@your-username/design-system` （個人名）
3. `@ds/core` （短縮形）
4. プロジェクト名があれば、それをベースに

**パッケージ名の例**:

- `@acme/core`
- `@acme/react`
- `@acme/vue`
- `@acme/tokens`

### 出力フォーマット（デザイントークン）

Style Dictionary からの出力フォーマットを決定：

**推奨**:

- CSS Variables（メイン）
- TypeScript 型定義
- JSON（ドキュメント用）

**必要であれば**:

- SCSS 変数
- Less 変数
- JavaScript オブジェクト

---

**次のアクションを教えてください！**

1. パッケージ名を決めますか？（または後で決める）
2. すぐにプロジェクトセットアップを開始しますか？
3. 他に確認したいことはありますか？
